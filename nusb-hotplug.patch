diff --git a/Cargo.toml b/Cargo.toml
index ac87aebfe4..08857d280f 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -26,7 +26,7 @@
 linux-raw-sys = { version = "0.9.2", features = ["ioctl"] }
 
 [target.'cfg(target_os="windows")'.dependencies]
-windows-sys = { version = "0.60.2", features = ["Win32_Devices_Usb", "Win32_Devices_DeviceAndDriverInstallation", "Win32_Foundation", "Win32_Devices_Properties", "Win32_Storage_FileSystem", "Win32_Security", "Win32_System_IO", "Win32_System_Registry", "Win32_System_Com"] }
+windows-sys = { version = "0.60.2", features = ["Win32_Devices_Usb", "Win32_Devices_DeviceAndDriverInstallation", "Win32_Foundation", "Win32_Devices_Properties", "Win32_Storage_FileSystem", "Win32_Security", "Win32_System_IO", "Win32_System_Registry", "Win32_System_Com", "Win32_System_Ioctl"] }
 
 [target.'cfg(target_os="macos")'.dependencies]
 core-foundation = "0.10.1"
diff --git a/src/hotplug.rs b/src/hotplug.rs
index 1b5ce1ac01..73764377b9 100644
--- a/src/hotplug.rs
+++ b/src/hotplug.rs
@@ -31,6 +31,9 @@
     /// A device has been connected.
     Connected(DeviceInfo),
 
+    /// Serial device connected
+    SerialConnected(DeviceInfo),
+
     /// A device has been disconnected.
     Disconnected(DeviceId),
 }
diff --git a/src/platform/macos_iokit/hotplug.rs b/src/platform/macos_iokit/hotplug.rs
index f9e5f53455..48a6e4f412 100644
--- a/src/platform/macos_iokit/hotplug.rs
+++ b/src/platform/macos_iokit/hotplug.rs
@@ -6,6 +6,7 @@
 };
 
 use core_foundation::{base::TCFType, dictionary::CFDictionary, runloop::CFRunLoopSource};
+use io_kit_sys::serial::keys::kIOSerialBSDServiceValue;
 use io_kit_sys::{
     kIOMasterPortDefault,
     keys::{kIOFirstMatchNotification, kIOTerminatedNotification},
@@ -52,6 +53,7 @@
     waker_id: SlabWaker,
     terminated_iter: IoServiceIterator,
     matched_iter: IoServiceIterator,
+    cdc_matched_iter: IoServiceIterator,
     _registration: EventRegistration,
     _notification_port: NotificationPort,
 }
@@ -84,6 +86,14 @@
             CFDictionary::wrap_under_create_rule(d)
         };
 
+        let cdc_dictionary = unsafe {
+            let d = IOServiceMatching(kIOSerialBSDServiceValue);
+            if d.is_null() {
+                return Err(Error::new(ErrorKind::Other, "IOServiceMatching failed"));
+            }
+            CFDictionary::wrap_under_create_rule(d)
+        };
+
         let notification_port = NotificationPort::new();
         let terminated_iter = register_notification(
             &notification_port,
@@ -97,6 +107,12 @@
             &waker_id,
             kIOFirstMatchNotification,
         )?;
+        let cdc_matched_iter = register_notification(
+            &notification_port,
+            &cdc_dictionary,
+            &waker_id,
+            kIOFirstMatchNotification,
+        )?;
 
         let source = unsafe {
             CFRunLoopSource::wrap_under_get_rule(IONotificationPortGetRunLoopSource(
@@ -109,6 +125,7 @@
             waker_id,
             terminated_iter,
             matched_iter,
+            cdc_matched_iter,
             _registration: registration,
             _notification_port: notification_port,
         })
@@ -125,6 +142,14 @@
             }
         }
 
+        while let Some(s) = self.cdc_matched_iter.next() {
+            if let Some(dev) = probe_device(s) {
+                return Poll::Ready(HotplugEvent::SerialConnected(dev));
+            } else {
+                debug!("failed to probe serial connected device");
+            }
+        }
+
         if let Some(s) = self.terminated_iter.next() {
             if let Some(registry_id) = get_registry_id(&s) {
                 debug!("device {registry_id} disconnected");
diff --git a/src/platform/windows_winusb/enumeration.rs b/src/platform/windows_winusb/enumeration.rs
index 9dc23d5d4e..a4e74bc075 100644
--- a/src/platform/windows_winusb/enumeration.rs
+++ b/src/platform/windows_winusb/enumeration.rs
@@ -16,6 +16,7 @@
         DESCRIPTOR_TYPE_CONFIGURATION, DESCRIPTOR_TYPE_STRING,
     },
     maybe_future::{blocking::Blocking, MaybeFuture},
+    platform::windows_winusb::util::WCStr,
     BusInfo, DeviceInfo, Error, ErrorKind, InterfaceInfo, UsbControllerType,
 };
 
@@ -52,6 +53,41 @@
     })
 }
 
+pub fn probe_serial_device(devinst: DevInst) -> Option<DeviceInfo> {
+    let instance_id = devinst.get_property::<OsString>(DEVPKEY_Device_InstanceId)?;
+    let mut devinst = devinst;
+
+    if instance_id.to_string_lossy().starts_with("USB\\ROOT_HUB") {
+        return None;
+    }
+
+    log::debug!("Probing serial device {}", instance_id.display());
+
+    // Limit the number of iterations to avoid infinite loops,
+    // even though it's unlikely to happen.
+    let n = 100;
+
+    for _ in 0..n {
+        let interfaces = devinst.interfaces(GUID_DEVINTERFACE_USB_DEVICE);
+
+        let paths = interfaces.iter().count();
+
+        if paths > 0 {
+            return probe_device(devinst);
+        }
+
+        let instance_id = devinst.get_property::<OsString>(DEVPKEY_Device_Parent)?;
+
+        let parent_id: WCString = WCString::from(instance_id.as_os_str());
+
+        devinst = DevInst::from_instance_id(&parent_id)?;
+    }
+
+    // The code will go up the device tree until it ends up at the root of the device tree,
+    // where there is no parent. So this part should never be reached.
+    unreachable!("Failed to find parent USB device, and did not reach root of the device tree")
+}
+
 pub fn probe_device(devinst: DevInst) -> Option<DeviceInfo> {
     let instance_id = devinst.get_property::<OsString>(DEVPKEY_Device_InstanceId)?;
     if instance_id.to_string_lossy().starts_with("USB\\ROOT_HUB") {
diff --git a/src/platform/windows_winusb/hotplug.rs b/src/platform/windows_winusb/hotplug.rs
index ef963ef1f0..b94f913601 100644
--- a/src/platform/windows_winusb/hotplug.rs
+++ b/src/platform/windows_winusb/hotplug.rs
@@ -20,11 +20,14 @@
         Usb::GUID_DEVINTERFACE_USB_DEVICE,
     },
     Foundation::ERROR_SUCCESS,
+    System::Ioctl::GUID_DEVINTERFACE_COMPORT,
 };
 
 use crate::{
     hotplug::HotplugEvent,
-    platform::windows_winusb::{cfgmgr32::get_device_interface_property, util::WCString},
+    platform::windows_winusb::{
+        cfgmgr32::get_device_interface_property, enumeration::probe_serial_device, util::WCString,
+    },
     DeviceId, Error,
 };
 
@@ -35,6 +38,7 @@
 pub(crate) struct WindowsHotplugWatch {
     inner: *mut HotplugInner,
     registration: HCMNOTIFICATION,
+    registration_com: HCMNOTIFICATION,
 }
 
 struct HotplugInner {
@@ -45,6 +49,7 @@
 #[derive(Debug)]
 enum Action {
     Connect,
+    SerialConnect,
     Disconnect,
 }
 
@@ -86,9 +91,41 @@
             .log_error());
         }
 
+        let mut registration_com = ptr::null_mut();
+        let filter_com = CM_NOTIFY_FILTER {
+            cbSize: size_of::<CM_NOTIFY_FILTER>() as u32,
+            Flags: 0,
+            FilterType: CM_NOTIFY_FILTER_TYPE_DEVICEINTERFACE,
+            Reserved: 0,
+            u: CM_NOTIFY_FILTER_0 {
+                DeviceInterface: CM_NOTIFY_FILTER_0_0 {
+                    ClassGuid: GUID_DEVINTERFACE_COMPORT,
+                },
+            },
+        };
+
+        let cr_com = unsafe {
+            CM_Register_Notification(
+                &filter_com,
+                inner as *mut c_void,
+                Some(hotplug_callback_serial),
+                &mut registration_com,
+            )
+        };
+
+        if cr_com != CR_SUCCESS {
+            return Err(Error::new_os(
+                crate::ErrorKind::Other,
+                "failed to initialize hotplug notifications for serial",
+                cr,
+            )
+            .log_error());
+        }
+
         Ok(WindowsHotplugWatch {
             inner,
             registration,
+            registration_com,
         })
     }
 
@@ -109,6 +146,11 @@
                     return Poll::Ready(HotplugEvent::Connected(dev));
                 };
             }
+            Some((Action::SerialConnect, devinst)) => {
+                if let Some(dev) = probe_serial_device(devinst) {
+                    return Poll::Ready(HotplugEvent::SerialConnected(dev));
+                };
+            }
             Some((Action::Disconnect, devinst)) => {
                 return Poll::Ready(HotplugEvent::Disconnected(DeviceId(devinst)));
             }
@@ -132,6 +174,7 @@
             // immediately afterward without races.
             // [1]: https://learn.microsoft.com/en-us/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_notification
             CM_Unregister_Notification(self.registration);
+            CM_Unregister_Notification(self.registration_com);
             drop(Box::from_raw(self.inner));
         }
     }
@@ -171,3 +214,40 @@
 
     ERROR_SUCCESS
 }
+
+unsafe extern "system" fn hotplug_callback_serial(
+    _hnotify: HCMNOTIFICATION,
+    context: *const ::core::ffi::c_void,
+    action: CM_NOTIFY_ACTION,
+    eventdata: *const CM_NOTIFY_EVENT_DATA,
+    _eventdatasize: u32,
+) -> u32 {
+    let inner = unsafe { &*(context as *const HotplugInner) };
+
+    let action = match action {
+        CM_NOTIFY_ACTION_DEVICEINTERFACEARRIVAL => Action::SerialConnect,
+        _ => {
+            debug!("Hotplug callback: unknown or unhandled action {action}");
+            return ERROR_SUCCESS;
+        }
+    };
+
+    let device_interface =
+        unsafe { WCStr::from_ptr(addr_of!((*eventdata).u.DeviceInterface.SymbolicLink[0])) };
+
+    let device_instance =
+        get_device_interface_property::<WCString>(device_interface, DEVPKEY_Device_InstanceId)
+            .unwrap();
+    let devinst = DevInst::from_instance_id(&device_instance).unwrap();
+
+    if let Some(parent) = devinst.parent() {
+        debug!("Hotplug com callback: action={action:?}, instance={device_instance}");
+        inner.events.lock().unwrap().push_back((action, parent));
+        if let Some(w) = inner.waker.lock().unwrap().take() {
+            w.wake()
+        }
+    } else {
+        debug!("Hotplug com callback no parent devinst found: action={action:?}, instance={device_instance}");
+    }
+    ERROR_SUCCESS
+}
